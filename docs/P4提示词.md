# Phase 4 实现提示词：MIR 到 Rust 函数体转换

## 🎯 目标概述

实现 C2RustAgent 的 **Phase 4 - 函数体转换**，将 MIR（中间表示）完整转换为可编译的 Rust 代码。当前状态：
- ✅ **已完成**：C 源码 → AST → MIR 转换，函数签名生成
- ⏳ **待实现**：MIR 基本块 → Rust 函数体实现
- 📊 **测试项目**：littlefs-fuse（950 个函数，当前 338 个编译错误）

## 📋 核心任务清单

### 1. MIR 到 Rust 表达式转换（优先级：高）

**文件**：`src/mir.rs`、`src/codegen/expression.rs`（新建）

**任务**：
- [ ] 实现 `Rvalue` → Rust 表达式转换
  - [ ] `Use(Operand)` → 变量引用或常量
  - [ ] `BinaryOp(op, left, right)` → 二元运算（+、-、*、/、%、&、|、^、<<、>>）
  - [ ] `UnaryOp(op, operand)` → 一元运算（-、!、&、*）
  - [ ] `Ref(mutability, lvalue)` → 引用操作（&、&mut）
  - [ ] `AddrOf(lvalue)` → 取地址
  - [ ] `Deref(operand)` → 解引用
  - [ ] `Cast(operand, ty)` → 类型转换（as）
  - [ ] `Aggregate(kind, fields)` → 结构体/数组聚合

**示例输入**（MIR）：
```json
{
  "kind": "BinaryOp",
  "op": "Add",
  "left": { "Local": 1 },
  "right": { "Constant": { "Int": 42 } }
}
```

**预期输出**（Rust）：
```rust
_1 + 42
```

### 2. MIR 到 Rust 语句转换（优先级：高）

**文件**：`src/codegen/statement.rs`（新建）

**任务**：
- [ ] 实现 `Statement` → Rust 语句转换
  - [ ] `Assign(lvalue, rvalue)` → 赋值语句（`let` 或 `=`）
  - [ ] `FunctionCall` → 函数调用语句
  - [ ] `Drop(lvalue)` → drop 调用（可选优化）
  - [ ] `StorageLive/StorageDead` → 忽略或转为注释
  - [ ] `Nop` → 跳过

**示例输入**（MIR）：
```json
{
  "kind": "Assign",
  "lvalue": { "Local": 2 },
  "rvalue": {
    "kind": "BinaryOp",
    "op": "Add",
    "left": { "Local": 1 },
    "right": { "Constant": { "Int": 1 } }
  }
}
```

**预期输出**（Rust）：
```rust
let _2 = _1 + 1;
```

### 3. 控制流转换（优先级：高）

**文件**：`src/codegen/control_flow.rs`（新建）

**任务**：
- [ ] 实现基本块到 Rust 控制流的转换
  - [ ] `Goto(target)` → 标签跳转或循环结构
  - [ ] `SwitchInt(discr, targets)` → if-else 或 match 表达式
  - [ ] `Return` → return 语句
  - [ ] `Unreachable` → `unreachable!()`
  - [ ] `Call(func, args, dest, target)` → 函数调用 + 跳转

**算法要求**：
- 识别循环结构（通过支配树分析）
- 识别 if-else 结构
- 处理多路分支（switch）
- 保证控制流等价性

**示例**：
```rust
// MIR: bb0 -> SwitchInt(_1, [0 -> bb1, _ -> bb2])
// Rust:
if _1 == 0 {
    // bb1 的语句
} else {
    // bb2 的语句
}
```

### 4. 类型系统完善（优先级：高）

**文件**：`src/ast_to_mir.rs`（已存在）

**任务**：
- [ ] 添加缺失 C 类型的处理
  - [ ] `Elaborated` 类型（结构体/枚举，约 600 处）
  - [ ] `ULongLong`/`LongLong` 类型（约 130 处）
  - [ ] `Bool` 类型（约 15 处）
  - [ ] `UShort`、`UInt`、`ULong` 类型
  - [ ] `LongDouble` 类型
  - [ ] `Typedef` 类型（需解析原始类型）
  - [ ] `ConstantArray` 类型

**参考**：`translate_littlefs_fuse/TRANSLATION_RESULT.md` 中的类型统计

**示例修改**（`ast_to_mir.rs` 中的 `convert_type` 函数）：
```rust
TypeKind::Elaborated => {
    // 解析结构体/枚举名称
    let name = entity.get_name()?;
    MirType::Struct { name }
}
TypeKind::ULongLong => MirType::U64,
TypeKind::LongLong => MirType::I64,
TypeKind::Bool => MirType::Bool,
```

### 5. 代码生成器重构（优先级：中）

**文件**：`src/codegen/mod.rs`（新建或修改现有生成器）

**任务**：
- [ ] 创建模块化代码生成架构
  ```
  src/codegen/
    ├── mod.rs              # 主入口，CodeGenerator
    ├── expression.rs       # 表达式生成
    ├── statement.rs        # 语句生成
    ├── control_flow.rs     # 控制流生成
    ├── types.rs            # 类型转换
    └── llm_enhancement.rs  # LLM 增强（可选）
  ```

- [ ] 实现 `CodeGenerator::generate_function_body()`
  ```rust
  pub fn generate_function_body(&self, func: &MirFunction) -> String {
      let mut code = String::new();
      
      // 1. 生成局部变量声明
      for local in &func.locals {
          code.push_str(&format!("let mut {}: {};\n", 
              local.name, self.type_to_rust(&local.ty)));
      }
      
      // 2. 转换基本块为控制流结构
      let cfg = self.analyze_control_flow(&func.basic_blocks);
      code.push_str(&self.generate_control_flow(&cfg));
      
      code
  }
  ```

### 6. LLM 语义增强集成（优先级：中）

**文件**：`src/codegen/llm_enhancement.rs`（新建）

**任务**：
- [ ] 使用 DeepSeek API 增强生成代码
  - [ ] 函数文档生成（基于函数名和签名推断用途）
  - [ ] unsafe 块安全注释生成
  - [ ] 资源管理语义标注（malloc/free 配对）
  - [ ] 变量命名优化（将 `_1`、`_2` 转为语义化名称）

**API 配置**：已存在于 `c2rust-agent.toml`
```toml
[llm]
provider = "openai"
api_key = "sk-7862c4aa401c403ea499e582eaf14f88"
api_url = "https://api.deepseek.com"
model = "deepseek-coder"
temperature = 0.3
max_tokens = 2000
```

**示例 Prompt**：
```rust
let prompt = format!(
    "为以下 Rust 函数生成文档注释，推断其用途和参数含义：\n\n{}\n\n返回格式：\n/// 函数用途\n/// \n/// # Arguments\n/// * `param1` - 参数说明",
    function_signature
);
```

### 7. 测试与验证（优先级：高）

**文件**：`tests/phase4_codegen.rs`（新建）

**任务**：
- [ ] 创建单元测试
  - [ ] 简单表达式转换（算术、逻辑）
  - [ ] 赋值语句转换
  - [ ] if-else 转换
  - [ ] while 循环转换
  - [ ] 函数调用转换
  - [ ] 指针操作转换

**测试用例示例**：
```rust
#[test]
fn test_binary_expression() {
    let mir = parse_mir(r#"
        fn add(a: i32, b: i32) -> i32 {
            bb0: {
                _2 = Add(_0, _1);
                return _2;
            }
        }
    "#);
    
    let rust = generate_code(&mir);
    assert!(rust.contains("a + b"));
}
```

- [ ] 集成测试：使用 littlefs-fuse 项目验证
  ```powershell
  cargo run --example generate_littlefs_rust
  cd translate_littlefs_fuse/generated_rust
  cargo build 2>&1 | Select-String "error" | Measure-Object
  # 目标：将 338 个错误降至 0
  ```

## 📂 项目结构变更

```
src/
├── main.rs                    # 主入口（已存在）
├── mir.rs                     # MIR 定义（已存在）
├── ast_to_mir.rs              # AST→MIR 转换（需修改）
├── codegen/                   # 新增目录
│   ├── mod.rs                 # 代码生成主模块
│   ├── expression.rs          # 表达式生成
│   ├── statement.rs           # 语句生成
│   ├── control_flow.rs        # 控制流生成
│   ├── types.rs               # 类型转换
│   └── llm_enhancement.rs     # LLM 增强
├── analysis/                  # 静态分析（已存在）
│   ├── mod.rs
│   ├── liveness.rs
│   └── control_flow.rs        # 新增：控制流分析
└── project_loader.rs          # 项目加载（已存在）

examples/
├── generate_littlefs_rust.rs  # littlefs 转译示例（已存在）
└── test_simple_codegen.rs     # 新增：简单代码生成测试

tests/
└── phase4_codegen.rs          # 新增：Phase 4 单元测试
```

## 🔧 实现步骤建议

### Step 1: 表达式转换（1-2 天）
1. 在 `src/mir.rs` 中完善 `Rvalue` 枚举定义
2. 创建 `src/codegen/expression.rs`
3. 实现 `rvalue_to_rust(rvalue: &Rvalue) -> String`
4. 编写单元测试验证

### Step 2: 语句转换（1 天）
1. 创建 `src/codegen/statement.rs`
2. 实现 `statement_to_rust(stmt: &Statement) -> String`
3. 处理变量声明和赋值

### Step 3: 控制流转换（2-3 天）
1. 创建 `src/analysis/control_flow.rs`
2. 实现循环检测算法（支配树分析）
3. 创建 `src/codegen/control_flow.rs`
4. 实现 if-else、while、match 生成

### Step 4: 类型系统完善（1 天）
1. 修改 `src/ast_to_mir.rs` 中的 `convert_type()`
2. 添加所有缺失类型的处理
3. 运行 littlefs 转译验证类型覆盖率

### Step 5: 集成测试（1 天）
1. 重新运行 `cargo run --example generate_littlefs_rust`
2. 分析剩余编译错误
3. 修复高频错误模式

### Step 6: LLM 增强（可选，1-2 天）
1. 创建 `src/codegen/llm_enhancement.rs`
2. 集成 DeepSeek API 调用
3. 批量生成文档和安全注释

## 📊 成功标准

- [ ] littlefs-fuse 项目编译错误从 338 降至 **< 50**
- [ ] 至少 80% 的函数能生成完整函数体
- [ ] 所有单元测试通过
- [ ] 生成代码通过 `cargo fmt` 和 `cargo clippy` 检查
- [ ] 性能：950 个函数转换时间 < 30 秒（不含 LLM 调用）

## 🔗 相关资源

- **MIR 规范**：`docs/phase2_mir.md`
- **当前 MIR 定义**：`src/mir.rs`
- **类型问题统计**：`translate_littlefs_fuse/TRANSLATION_RESULT.md`
- **DeepSeek 配置**：`docs/DEEPSEEK_CONFIG_GUIDE.md`
- **项目架构**：`.github/copilot-instructions.md`

## 💡 提示

1. **增量开发**：先实现简单表达式/语句，再处理复杂控制流
2. **参考现有代码**：`examples/test_deepseek.rs` 展示了 LLM API 使用方式
3. **调试工具**：使用 `cargo run --example generate_littlefs_rust` 快速验证
4. **错误分类**：先解决高频错误（E0069），再处理边缘情况
5. **保持简洁**：初期生成的代码可以较冗余，优化可后续进行

## 📝 提交前检查

- [ ] 所有新文件都有模块文档注释
- [ ] 公开 API 都有 rustdoc 注释
- [ ] 运行 `cargo fmt` 格式化代码
- [ ] 运行 `cargo clippy` 无警告
- [ ] 运行 `cargo test` 所有测试通过
- [ ] 更新 `README.md` 和 `docs/` 相关文档

---

**开始指令**：
```
我要实现 C2RustAgent 的 Phase 4 函数体转换功能。请按照 `docs/PHASE4_IMPLEMENTATION_PROMPT.md` 中的任务清单，从 Step 1（表达式转换）开始，帮我创建必要的文件和实现代码。目标是将 littlefs-fuse 项目的 338 个编译错误降至最少。
```
